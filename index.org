#+TITLE: Algebraic Data Types
#+OPTIONS: toc:1, num:nil
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js@3.8.0
#+REVEAL_THEME: moon

* What's a Type?

** A type can be thought of as a set of values 
#+ATTR_REVEAL: :frag (appear)
- An ~int~ can hold only the integers
- A ~boolean~ can hold only the values ~true~ and ~false~
- A value of type ~RGBColor~ may only be able to hold the values ~Red~, ~Green~ and ~Blue~
- A value of type ~SomeClass~ can hold instances of ~SomeClass~ or its sub-classes

* Product Types

** You've Probably Used Them Before
#+ATTR_REVEAL: :frag (appear)
- pair
- tuple
- record
- struct
- class

* Sum Types

** Also Known As
#+ATTR_REVEAL: :frag (appear)
- tagged union
- variant
- "one of" type

** Sum Types
Used to create a new type from two or more existing types.
#+ATTR_REVEAL: :frag (appear)
For example, you could create a type that could hold an integer /or/ a string.

** Haskell's Canonical Union
In Haskell, the ~Either~ data type is used for this purpose:
#+begin_src haskell
data Either a b = Left a | Right b
type IntOrString = Either Int String

someData :: IntOrString
someData = Left 42 -- or Right "Hello!"
#+end_src

#+begin_src haskell
someFunction :: IntOrString -> String
someFunction (Left i) = show i
someFunction (Right s) = s
#+end_src

** In Scala
#+HEADER: :exports both
#+begin_src scala :dir ./ensime-test :results pp
sealed trait Either[A, B]
case class Left[A, B](a: A) extends Either[A, B]
case class Right[A, B](b: B) extends Either[A, B]

type IntOrString = Either[Int, String]
val someData: IntOrString = Left(42) // or Right("Hello!")
#+end_src

** What About Three Types?
In Haskell:
#+begin_src haskell
type IntOrStringOrBool = Either Int (Either String Bool)

someInt :: IntOrStringOrBool
someInt = Left 42

someString :: IntOrStringOrBool
someString = Right (Left "Hello!")

someBool :: IntOrStringOrBool
someBool = Right (Right True)
#+end_src

** More About Unions
tagged, untagged, discriminated, disjoint
