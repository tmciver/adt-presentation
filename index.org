#+TITLE: Algebraic Data Types
#+OPTIONS: toc:1, num:nil
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js@3.8.0
#+REVEAL_THEME: moon

* What's a Type?

** A type can be thought of as a set of values 
#+ATTR_REVEAL: :frag (appear)
- An ~int~ can hold only the integers
- A ~boolean~ can hold only the values ~true~ and ~false~
- A value of type ~RGBColor~ may only be able to hold the values ~Red~, ~Green~ and ~Blue~
- A value of type ~SomeClass~ can hold instances of ~SomeClass~ or its sub-classes

* Sum Types

** Also Known As
#+ATTR_REVEAL: :frag (appear)
- tagged union
- variant
- "one of" type

** Sum Types
Used to create a new type from two or more existing types.
#+ATTR_REVEAL: :frag (appear)
For example, you could create a type that could hold an integer /or/ a string.

** Haskell's Canonical Union
In Haskell, the ~Either~ data type is used for this purpose:
#+begin_src haskell
data Either a b = Left a | Right b
type IntOrString = Either Int String

someData :: IntOrString
someData = Left 42 -- or Right "Hello!"
#+end_src

#+begin_src haskell
someFunction :: IntOrString -> String
someFunction (Left i) = show i
someFunction (Right s) = s
#+end_src

** In Scala
#+HEADER: :exports both
#+begin_src scala :dir ./ensime-test :results pp
sealed trait Either[A, B]
case class Left[A, B](a: A) extends Either[A, B]
case class Right[A, B](b: B) extends Either[A, B]

type IntOrString = Either[Int, String]
val someData: IntOrString = Left(42) // or Right("Hello!")
#+end_src

** What About Three Types?
In Haskell:
#+begin_src haskell
type IntOrStringOrBool = Either Int (Either String Bool)

someInt :: IntOrStringOrBool
someInt = Left 42

someString :: IntOrStringOrBool
someString = Right (Left "Hello!")

someBool :: IntOrStringOrBool
someBool = Right (Right True)
#+end_src

** What About Three Types?
Could have also reused ~IntOrString~
#+begin_src haskell
type IntOrStringOrBool = Either IntOrString Bool

someInt :: IntOrStringOrBool
someInt = Left (Left 42)

someString :: IntOrStringOrBool
someString = Left (Right "Hello!")

someBool :: IntOrStringOrBool
someBool = Right True

toString :: IntOrStringOrBool -> String
toString (Left (Left i)) = show i
toString (Left (Right s)) = s
toString (Right b) = show b
#+end_src

** A Better Way
But most languages that support sum types make this much easier.
#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
data IntOrStringOrBool = I Int
                       | S String
                       | B Bool
#+end_src
#+ATTR_REVEAL: :frag (appear)
#+begin_group
And then ~toString~ becomes:
#+begin_src haskell
toString :: IntOrStringOrBool -> String
toString (I i) = show i
toString (S s) = s
toString (B b) = show b
#+end_src
#+end_group

** Constructors Don't /Need/ to Accept Values
#+begin_src haskell
data RGBColor = Red
              | Green
              | Blue
#+end_src

** How Many Members?
#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
data RGBColor = Red | Green | Blue
-- {Red, Green, Blue}
#+end_src

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
data RGBColorOrBool = RGB RGBColor
                    | B Bool
-- {RGB Red, RGB Green, RGB Blue, B True, B False}
#+end_src

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
data Int16OrRGBColorOrBool = I Int16 | RGBColor | B Bool
-- 65,536 + 5 = 65,541
#+end_src

#+ATTR_REVEAL: :frag (appear)
The total number of members is the /sum/ of the members from each constructor.

** The Constructors /Tag/ the Values
Why can't we do this?
#+begin_src haskell
type RGBColorOrBool = RGBColor
                    | Bool
#+end_src

Instead of this?
#+begin_src haskell
data RGBColorOrBool = RGB RGBColor
                    | B Bool
#+end_src

** The Constructors /Tag/ the Values (Continued)

#+begin_group
Because of situations like this:
#+begin_src haskell
data TurnDirection = Left | Right
data MoralDirection = Right | Wrong
type Direction = TurnDirection | MoralDirection -- invalid Haskell
#+end_src
#+end_group

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
isMoral :: Direction -> Bool
isMoral Right = True
isMoral _ = False
#+end_src

#+ATTR_REVEAL: :frag (appear)
What ~Right~ did we get?

* Product Type

** You've Probably Used Them Before
#+ATTR_REVEAL: :frag (appear)
- pair
- tuple
- record
- struct
- class

** Pairs and Tuples
Tuples are like lists of values with two important exceptions:
#+ATTR_REVEAL: :frag (appear)
- They are heterogenous, i.e., each position can have a different type.
- Their size is fixed, i.e., you cannot add an element.

#+ATTR_REVEAL: :frag (appear)
A pair is simply a two-element tuple.

** Tuple Examples
#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
type Point = (Double, Double) -- (x, y)
#+end_src

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
type Person = (String, String, Int)
-- (First name, last name, age)
#+end_src

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
type Score = Int
type Player = (Person, Score)
#+end_src

* More About Unions
tagged, untagged, discriminated, disjoint
